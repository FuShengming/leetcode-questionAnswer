/*
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/next-permutation
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

/*
本题要求只能原地修改，且额外使用的空间复杂度必须是O(1)。
此题关键在于对字典序的，所谓的“下一排序”的变换规则的理解。
举个例子，23541的下一排序为24135
我们对这个变换仔细观察：
第一个改变的数字是3，它的特点是，是从后向前的遍历中第一次出现数字减小的位置。
上面这句话的意思是：
对23541从后向前遍历，第一个数字为1，第二个为4，1<4，没出现数字减小。
直到前一个数字为5，后一个数字为3时，5>3，出现了数字的减小。则3是需要变化的第一个数字，我们称其位置为x位置。

详细的解释，实质上没出现数字减小的数字序列为541，能够看出实际上541正是145这三个数字的最后一个排列。
所以541已经无法在进行所谓的“下一个序列”的变化，所以需要变化的是541前面的数字，即3,序列3541是可以变换的。
所以，实际上我们寻找的是最长的，已经到达“最后一个排列”，无法进行变换的排列。
这个被找到的最长排列再加上前面一个数字也就组成了我们需要对其进行变换的排列。

接着，我们可以看到3541变幻成了4135，因为是字典序变换，我们需要的实际上是：
找到3后面的，我们所找到的“最长无法变换序列”中，在序列中最小，且大于3的数字。
这个数字将是3541的下一个序列的开头数字。
即，541中，比3大的有4，5，其中最小的是4。这个数字为3451得下一个序列的开头数字。
然后，我们只需要对剩下的数字字典序排序即可。
因为实际上，我们在要找到的是，找到的开头数字为开头的第一个排列。
在这个例子中则是找到4开头，剩下5，1，3，字典序排序为135，所以我们最后得到的排列为4135。

最后再加上x位置之前的数字，则得到最后的结果，24135.

对原地修改的要求只需要我们找到4之后，将4与x位置的3交换位置。
然后对x位置后（不包括x位置，因为现在已经被换为4）的数字进行字典序排序即可。这边我直接用了简单的冒泡排序。

另外就是注意，没有找到x位置的情况，即没有找到从后向前遍历时数字出现减小的情况，即数字序列从后向前一直增加，即54321，65443322这种格式。
显然这种情况就是这组数字的最后一个排列，按照题目要求，直接返回这些数字的第一个排列，即字典序即可。
*/

//1ms,时间打败99.77%，空间打败99.45%
class Solution {
    public void nextPermutation(int[] nums) {
        int n = nums.length;
        if(n==0){return;}
        boolean has = false;
        int i = n-1;
        for(;i>=1;i--){
            if(nums[i]>nums[i-1]){
                i--;
                //找到需要变换的序列的头位置
                has = true;
                int cur = nums[i];
                int minIndex = i+1;
                int min = nums[i+1];
                for(int j = i+1;j<n;j++){
                    //找到头位置需要交换为的数字
                    if(nums[j]<min&&nums[j]>cur){
                        min = nums[j];
                        minIndex=j;
                    }
                }
                int tempCur = nums[i];
                nums[i] = nums[minIndex];
                nums[minIndex] = tempCur;                                                                                                   
                for(int j=i+1;j<n-1;j++){
                    //对头位置之后的位置进行字典序排序
                    for(int k=j+1;k<n;k++){
                        if(nums[j]>nums[k]){
                            int temp = nums[k];
                            nums[k]=nums[j];
                            nums[j]=temp;
                        }
                    }
                }  
                break;                             
            }
        }        
         if(!has){Arrays.sort(nums);}//已经是最后一个序列
    }
}